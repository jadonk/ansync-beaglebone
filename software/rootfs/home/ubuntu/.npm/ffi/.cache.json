{"_id":"ffi","_rev":"47-03f91b72c256243c39c42351172d5504","name":"ffi","description":"A foreign function interface (FFI) for Node.js","dist-tags":{"latest":"1.2.3"},"versions":{"1.0.0":{"name":"ffi","version":"1.0.0","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*"},"scripts":{"test":"cd test && node-gyp rebuild && mocha -gc --reporter spec *.js","install":"node-gyp rebuild"},"repository":{"type":"git","url":"git://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"_npmUser":{"name":"tootallnate","email":"nathan@tootallnate.net"},"_id":"ffi@1.0.0","optionalDependencies":{},"_engineSupported":true,"_npmVersion":"1.1.18","_nodeVersion":"v0.7.9","_defaultsLoaded":true,"dist":{"shasum":"c9be0fa34d31424a2134641cfb90c48ea3ec1fc1","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.0.0.tgz"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.0.1":{"name":"ffi","version":"1.0.1","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*"},"scripts":{"test":"cd test && node-gyp rebuild && mocha -gc --reporter spec *.js","install":"node-gyp rebuild"},"repository":{"type":"git","url":"git://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"_npmUser":{"name":"tootallnate","email":"nathan@tootallnate.net"},"_id":"ffi@1.0.1","optionalDependencies":{},"_engineSupported":true,"_npmVersion":"1.1.25","_nodeVersion":"v0.7.10","_defaultsLoaded":true,"dist":{"shasum":"d5666a7846e71b16078e2a338f2d2fb7985bda90","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.0.1.tgz"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.0.3":{"name":"ffi","version":"1.0.3","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*"},"scripts":{"test":"node-gyp rebuild --directory test && mocha -gc --reporter spec","install":"node-gyp rebuild"},"repository":{"type":"git","url":"http://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"gypfile":true,"readme":"node-ffi\n========\n### Node.js Foreign Function Interface [![Build Status](https://secure.travis-ci.org/rbranson/node-ffi.png)](http://travis-ci.org/rbranson/node-ffi)\n\n## Attention node-ffi users! v1.0 has been released! See the [API changes page][v1apichanges].\n\n`node-ffi` is a Node.js addon for loading and calling dynamic libraries using\npure JavaScript. It can be used to create bindings to native libraries without\nwriting any C++ code.\n\nIt also simplifies the augmentation of node.js with C code as it takes care of\nhandling the translation of types across JavaScript and C, which can add reams\nof boilerplate code to your otherwise simple C. See the `example/factorial`\nfor an example of this use case.\n\n**WARNING**: node-ffi assumes you know what you're doing. You can pretty easily\ncreate situations where you will segfault the interpreter and unless you've got\nC debugger skills, you probably won't know what's going on.\n\n\nExample\n-------\n\n``` js\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\nFor a more detailed introduction, see the [node-ffi tutorial page][tutorial].\n\n\nRequirements\n------------\n\n * Linux, OS X, Windows, or Solaris.\n * `libffi` comes bundled with node-ffi; it does *not* need to be installed on your system.\n * The current version is tested to run on node v0.6, v0.7, and v0.8.\n\n\nInstallation\n------------\n\n``` bash\n$ npm install ffi\n```\n\n__Note:__ When installing on Windows, you'll need to invoke `npm install ffi` from\nwithin a [Mozilla Build](https://wiki.mozilla.org/MozillaBuild) ([direct\nlink](http://ftp.mozilla.org/pub/mozilla.org/mozilla/libraries/win32/MozillaBuildSetup-Latest.exe)) command window.\n\nSource Install / Manual Compilation\n-----------------------------------\n\nTo compile from source it's easiest to use\n[`node-gyp`](https://github.com/TooTallNate/node-gyp):\n\n``` bash\n$ npm install -g node-gyp\n```\n\nNow you can compile `node-ffi`:\n\n``` bash\n$ git clone git://github.com/rbranson/node-ffi.git\n$ cd node-ffi\n$ node-gyp configure build\n```\n\n\nTypes\n-----\n\nThe types that you specify in function declarations correspond to ref's types\nsystem. So [see its docs][ref-types] for\na reference if you are unfamiliar.\n\n\nV8 and 64-bit Types\n-------------------\n\nInternally, V8 stores integers that will fit into a 32-bit space in a 32-bit\ninteger, and those that fall outside of this get put into double-precision\nfloating point numbers. This is problematic because FP numbers are imprecise.\nTo get around this, the methods in node-ffi that deal with 64-bit integers return\nstrings and can accept strings as parameters.\n\nCall Overhead\n-------------\n\nThere is non-trivial overhead associated with FFI calls. Comparing a hard-coded\nbinding version of `strtoul()` to an FFI version of `strtoul()` shows that the\nnative hard-coded binding is orders of magnitude faster. So don't just use the\nC version of a function just because it's faster. There's a significant cost in\nFFI calls, so make them worth it.\n\nLicense\n-------\n\nMIT License. See the `LICENSE` file.\n\n[v1apichanges]: https://github.com/rbranson/node-ffi/wiki/API-changes-from-v0.x-to-v1.x\n[tutorial]: https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial\n[ref-types]: https://github.com/TooTallNate/ref#built-in-types\n","_id":"ffi@1.0.3","dist":{"shasum":"87d139481cec1b41fd31bb6567b2932fcff5ce86","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.0.3.tgz"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.0.4":{"name":"ffi","version":"1.0.4","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*"},"scripts":{"test":"node-gyp rebuild --directory test && mocha -gc --reporter spec","install":"node-gyp rebuild"},"repository":{"type":"git","url":"http://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"gypfile":true,"readme":"node-ffi\n========\n### Node.js Foreign Function Interface [![Build Status](https://secure.travis-ci.org/rbranson/node-ffi.png)](http://travis-ci.org/rbranson/node-ffi)\n\n## Attention node-ffi users! v1.0 has been released! See the [API changes page][v1apichanges].\n\n`node-ffi` is a Node.js addon for loading and calling dynamic libraries using\npure JavaScript. It can be used to create bindings to native libraries without\nwriting any C++ code.\n\nIt also simplifies the augmentation of node.js with C code as it takes care of\nhandling the translation of types across JavaScript and C, which can add reams\nof boilerplate code to your otherwise simple C. See the `example/factorial`\nfor an example of this use case.\n\n**WARNING**: node-ffi assumes you know what you're doing. You can pretty easily\ncreate situations where you will segfault the interpreter and unless you've got\nC debugger skills, you probably won't know what's going on.\n\n\nExample\n-------\n\n``` js\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\nFor a more detailed introduction, see the [node-ffi tutorial page][tutorial].\n\n\nRequirements\n------------\n\n * Linux, OS X, Windows, or Solaris.\n * `libffi` comes bundled with node-ffi; it does *not* need to be installed on your system.\n * The current version is tested to run on node v0.6, v0.7, and v0.8.\n\n\nInstallation\n------------\n\n``` bash\n$ npm install ffi\n```\n\n__Note:__ When installing on Windows, you'll need to invoke `npm install ffi` from\nwithin a [Mozilla Build](https://wiki.mozilla.org/MozillaBuild) ([direct\nlink](http://ftp.mozilla.org/pub/mozilla.org/mozilla/libraries/win32/MozillaBuildSetup-Latest.exe)) command window.\n\nSource Install / Manual Compilation\n-----------------------------------\n\nTo compile from source it's easiest to use\n[`node-gyp`](https://github.com/TooTallNate/node-gyp):\n\n``` bash\n$ npm install -g node-gyp\n```\n\nNow you can compile `node-ffi`:\n\n``` bash\n$ git clone git://github.com/rbranson/node-ffi.git\n$ cd node-ffi\n$ node-gyp configure build\n```\n\n\nTypes\n-----\n\nThe types that you specify in function declarations correspond to ref's types\nsystem. So [see its docs][ref-types] for\na reference if you are unfamiliar.\n\n\nV8 and 64-bit Types\n-------------------\n\nInternally, V8 stores integers that will fit into a 32-bit space in a 32-bit\ninteger, and those that fall outside of this get put into double-precision\nfloating point numbers. This is problematic because FP numbers are imprecise.\nTo get around this, the methods in node-ffi that deal with 64-bit integers return\nstrings and can accept strings as parameters.\n\nCall Overhead\n-------------\n\nThere is non-trivial overhead associated with FFI calls. Comparing a hard-coded\nbinding version of `strtoul()` to an FFI version of `strtoul()` shows that the\nnative hard-coded binding is orders of magnitude faster. So don't just use the\nC version of a function just because it's faster. There's a significant cost in\nFFI calls, so make them worth it.\n\nLicense\n-------\n\nMIT License. See the `LICENSE` file.\n\n[v1apichanges]: https://github.com/rbranson/node-ffi/wiki/API-changes-from-v0.x-to-v1.x\n[tutorial]: https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial\n[ref-types]: https://github.com/TooTallNate/ref#built-in-types\n","_id":"ffi@1.0.4","dist":{"shasum":"717d518f6ac09d391680b8bf88ae4bfc757bc8ea","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.0.4.tgz"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.0.5":{"name":"ffi","version":"1.0.5","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*"},"scripts":{"test":"node-gyp rebuild --directory test && mocha -gc --reporter spec","install":"node-gyp rebuild"},"repository":{"type":"git","url":"http://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"gypfile":true,"readme":"node-ffi\n========\n### Node.js Foreign Function Interface [![Build Status](https://secure.travis-ci.org/rbranson/node-ffi.png)](http://travis-ci.org/rbranson/node-ffi)\n\n## Attention node-ffi users! v1.0 has been released! See the [API changes page][v1apichanges].\n\n`node-ffi` is a Node.js addon for loading and calling dynamic libraries using\npure JavaScript. It can be used to create bindings to native libraries without\nwriting any C++ code.\n\nIt also simplifies the augmentation of node.js with C code as it takes care of\nhandling the translation of types across JavaScript and C, which can add reams\nof boilerplate code to your otherwise simple C. See the `example/factorial`\nfor an example of this use case.\n\n**WARNING**: node-ffi assumes you know what you're doing. You can pretty easily\ncreate situations where you will segfault the interpreter and unless you've got\nC debugger skills, you probably won't know what's going on.\n\n\nExample\n-------\n\n``` js\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\nFor a more detailed introduction, see the [node-ffi tutorial page][tutorial].\n\n\nRequirements\n------------\n\n * Linux, OS X, Windows, or Solaris.\n * `libffi` comes bundled with node-ffi; it does *not* need to be installed on your system.\n * The current version is tested to run on node v0.6, v0.7, and v0.8.\n\n\nInstallation\n------------\n\n``` bash\n$ npm install ffi\n```\n\n__Note:__ When installing on Windows, you'll need to invoke `npm install ffi` from\nwithin a [Mozilla Build](https://wiki.mozilla.org/MozillaBuild) ([direct\nlink](http://ftp.mozilla.org/pub/mozilla.org/mozilla/libraries/win32/MozillaBuildSetup-Latest.exe)) command window.\n\nSource Install / Manual Compilation\n-----------------------------------\n\nTo compile from source it's easiest to use\n[`node-gyp`](https://github.com/TooTallNate/node-gyp):\n\n``` bash\n$ npm install -g node-gyp\n```\n\nNow you can compile `node-ffi`:\n\n``` bash\n$ git clone git://github.com/rbranson/node-ffi.git\n$ cd node-ffi\n$ node-gyp configure build\n```\n\n\nTypes\n-----\n\nThe types that you specify in function declarations correspond to ref's types\nsystem. So [see its docs][ref-types] for\na reference if you are unfamiliar.\n\n\nV8 and 64-bit Types\n-------------------\n\nInternally, V8 stores integers that will fit into a 32-bit space in a 32-bit\ninteger, and those that fall outside of this get put into double-precision\nfloating point numbers. This is problematic because FP numbers are imprecise.\nTo get around this, the methods in node-ffi that deal with 64-bit integers return\nstrings and can accept strings as parameters.\n\nCall Overhead\n-------------\n\nThere is non-trivial overhead associated with FFI calls. Comparing a hard-coded\nbinding version of `strtoul()` to an FFI version of `strtoul()` shows that the\nnative hard-coded binding is orders of magnitude faster. So don't just use the\nC version of a function just because it's faster. There's a significant cost in\nFFI calls, so make them worth it.\n\nLicense\n-------\n\nMIT License. See the `LICENSE` file.\n\n[v1apichanges]: https://github.com/rbranson/node-ffi/wiki/API-changes-from-v0.x-to-v1.x\n[tutorial]: https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial\n[ref-types]: https://github.com/TooTallNate/ref#built-in-types\n","_id":"ffi@1.0.5","dist":{"shasum":"5dc110ed0d7f9e2518bf406a5e2425ba6f50b294","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.0.5.tgz"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.0.6":{"name":"ffi","version":"1.0.6","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*"},"scripts":{"test":"node-gyp rebuild --directory test && mocha -gc --reporter spec","install":"node-gyp rebuild"},"repository":{"type":"git","url":"http://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"gypfile":true,"readme":"node-ffi\n========\n### Node.js Foreign Function Interface [![Build Status](https://secure.travis-ci.org/rbranson/node-ffi.png)](http://travis-ci.org/rbranson/node-ffi)\n\n## Attention node-ffi users! v1.0 has been released! See the [API changes page][v1apichanges].\n\n`node-ffi` is a Node.js addon for loading and calling dynamic libraries using\npure JavaScript. It can be used to create bindings to native libraries without\nwriting any C++ code.\n\nIt also simplifies the augmentation of node.js with C code as it takes care of\nhandling the translation of types across JavaScript and C, which can add reams\nof boilerplate code to your otherwise simple C. See the `example/factorial`\nfor an example of this use case.\n\n**WARNING**: node-ffi assumes you know what you're doing. You can pretty easily\ncreate situations where you will segfault the interpreter and unless you've got\nC debugger skills, you probably won't know what's going on.\n\n\nExample\n-------\n\n``` js\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\nFor a more detailed introduction, see the [node-ffi tutorial page][tutorial].\n\n\nRequirements\n------------\n\n * Linux, OS X, Windows, or Solaris.\n * `libffi` comes bundled with node-ffi; it does *not* need to be installed on your system.\n * The current version is tested to run on node v0.6, v0.7, and v0.8.\n\n\nInstallation\n------------\n\n``` bash\n$ npm install ffi\n```\n\n__Note:__ When installing on Windows, you'll need to invoke `npm install ffi` from\nwithin a [Mozilla Build](https://wiki.mozilla.org/MozillaBuild) ([direct\nlink](http://ftp.mozilla.org/pub/mozilla.org/mozilla/libraries/win32/MozillaBuildSetup-Latest.exe)) command window.\n\nSource Install / Manual Compilation\n-----------------------------------\n\nTo compile from source it's easiest to use\n[`node-gyp`](https://github.com/TooTallNate/node-gyp):\n\n``` bash\n$ npm install -g node-gyp\n```\n\nNow you can compile `node-ffi`:\n\n``` bash\n$ git clone git://github.com/rbranson/node-ffi.git\n$ cd node-ffi\n$ node-gyp configure build\n```\n\n\nTypes\n-----\n\nThe types that you specify in function declarations correspond to ref's types\nsystem. So [see its docs][ref-types] for\na reference if you are unfamiliar.\n\n\nV8 and 64-bit Types\n-------------------\n\nInternally, V8 stores integers that will fit into a 32-bit space in a 32-bit\ninteger, and those that fall outside of this get put into double-precision\nfloating point numbers. This is problematic because FP numbers are imprecise.\nTo get around this, the methods in node-ffi that deal with 64-bit integers return\nstrings and can accept strings as parameters.\n\nCall Overhead\n-------------\n\nThere is non-trivial overhead associated with FFI calls. Comparing a hard-coded\nbinding version of `strtoul()` to an FFI version of `strtoul()` shows that the\nnative hard-coded binding is orders of magnitude faster. So don't just use the\nC version of a function just because it's faster. There's a significant cost in\nFFI calls, so make them worth it.\n\nLicense\n-------\n\nMIT License. See the `LICENSE` file.\n\n[v1apichanges]: https://github.com/rbranson/node-ffi/wiki/API-changes-from-v0.x-to-v1.x\n[tutorial]: https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial\n[ref-types]: https://github.com/TooTallNate/ref#built-in-types\n","_id":"ffi@1.0.6","dist":{"shasum":"d239055064e67ad7c0d8d1b481fd458e89a963e9","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.0.6.tgz"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.0.7":{"name":"ffi","version":"1.0.7","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*"},"scripts":{"test":"node-gyp rebuild --directory test && mocha -gc --reporter spec","install":"node-gyp rebuild"},"repository":{"type":"git","url":"http://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"gypfile":true,"readme":"node-ffi\n========\n### Node.js Foreign Function Interface [![Build Status](https://secure.travis-ci.org/rbranson/node-ffi.png)](http://travis-ci.org/rbranson/node-ffi)\n\n## Attention node-ffi users! v1.0 has been released! See the [API changes page][v1apichanges].\n\n`node-ffi` is a Node.js addon for loading and calling dynamic libraries using\npure JavaScript. It can be used to create bindings to native libraries without\nwriting any C++ code.\n\nIt also simplifies the augmentation of node.js with C code as it takes care of\nhandling the translation of types across JavaScript and C, which can add reams\nof boilerplate code to your otherwise simple C. See the `example/factorial`\nfor an example of this use case.\n\n**WARNING**: node-ffi assumes you know what you're doing. You can pretty easily\ncreate situations where you will segfault the interpreter and unless you've got\nC debugger skills, you probably won't know what's going on.\n\n\nExample\n-------\n\n``` js\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\nFor a more detailed introduction, see the [node-ffi tutorial page][tutorial].\n\n\nRequirements\n------------\n\n * Linux, OS X, Windows, or Solaris.\n * `libffi` comes bundled with node-ffi; it does *not* need to be installed on your system.\n * The current version is tested to run on node v0.6, v0.7, and v0.8.\n\n\nInstallation\n------------\n\n``` bash\n$ npm install ffi\n```\n\n__Note:__ When installing on Windows, you'll need to invoke `npm install ffi` from\nwithin a [Mozilla Build](https://wiki.mozilla.org/MozillaBuild) ([direct\nlink](http://ftp.mozilla.org/pub/mozilla.org/mozilla/libraries/win32/MozillaBuildSetup-Latest.exe)) command window.\n\nSource Install / Manual Compilation\n-----------------------------------\n\nTo compile from source it's easiest to use\n[`node-gyp`](https://github.com/TooTallNate/node-gyp):\n\n``` bash\n$ npm install -g node-gyp\n```\n\nNow you can compile `node-ffi`:\n\n``` bash\n$ git clone git://github.com/rbranson/node-ffi.git\n$ cd node-ffi\n$ node-gyp configure build\n```\n\n\nTypes\n-----\n\nThe types that you specify in function declarations correspond to ref's types\nsystem. So [see its docs][ref-types] for\na reference if you are unfamiliar.\n\n\nV8 and 64-bit Types\n-------------------\n\nInternally, V8 stores integers that will fit into a 32-bit space in a 32-bit\ninteger, and those that fall outside of this get put into double-precision\nfloating point numbers. This is problematic because FP numbers are imprecise.\nTo get around this, the methods in node-ffi that deal with 64-bit integers return\nstrings and can accept strings as parameters.\n\nCall Overhead\n-------------\n\nThere is non-trivial overhead associated with FFI calls. Comparing a hard-coded\nbinding version of `strtoul()` to an FFI version of `strtoul()` shows that the\nnative hard-coded binding is orders of magnitude faster. So don't just use the\nC version of a function just because it's faster. There's a significant cost in\nFFI calls, so make them worth it.\n\nLicense\n-------\n\nMIT License. See the `LICENSE` file.\n\n[v1apichanges]: https://github.com/rbranson/node-ffi/wiki/API-changes-from-v0.x-to-v1.x\n[tutorial]: https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial\n[ref-types]: https://github.com/TooTallNate/ref#built-in-types\n","_id":"ffi@1.0.7","dist":{"shasum":"0b62f4881d642c42328f9817f377d0c8a3075bc9","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.0.7.tgz"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.1.0":{"name":"ffi","version":"1.1.0","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*"},"scripts":{"test":"node-gyp rebuild --directory test && mocha -gc --reporter spec","install":"node-gyp rebuild"},"repository":{"type":"git","url":"http://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"gypfile":true,"readme":"node-ffi\n========\n### Node.js Foreign Function Interface [![Build Status](https://secure.travis-ci.org/rbranson/node-ffi.png)](http://travis-ci.org/rbranson/node-ffi)\n\n`node-ffi` is a Node.js addon for loading and calling dynamic libraries using\npure JavaScript. It can be used to create bindings to native libraries without\nwriting any C++ code.\n\nIt also simplifies the augmentation of node.js with C code as it takes care of\nhandling the translation of types across JavaScript and C, which can add reams\nof boilerplate code to your otherwise simple C. See the `example/factorial`\nfor an example of this use case.\n\n**WARNING**: node-ffi assumes you know what you're doing. You can pretty easily\ncreate situations where you will segfault the interpreter and unless you've got\nC debugger skills, you probably won't know what's going on.\n\nExample\n-------\n\n``` js\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\nFor a more detailed introduction, see the [node-ffi tutorial page][tutorial].\n\nRequirements\n------------\n\n * Linux, OS X, Windows, or Solaris.\n * `libffi` comes bundled with node-ffi; it does *not* need to be installed on your system.\n * The current version is tested to run on node v0.6, v0.7, and v0.8.\n\nInstallation\n------------\n\n``` bash\n$ npm install ffi\n```\n\nSource Install / Manual Compilation\n-----------------------------------\n\nTo compile from source it's easiest to use\n[`node-gyp`](https://github.com/TooTallNate/node-gyp):\n\n``` bash\n$ npm install -g node-gyp\n```\n\nNow you can compile `node-ffi`:\n\n``` bash\n$ git clone git://github.com/rbranson/node-ffi.git\n$ cd node-ffi\n$ node-gyp rebuild\n```\n\nTypes\n-----\n\nThe types that you specify in function declarations correspond to ref's types\nsystem. So [see its docs][ref-types] for\na reference if you are unfamiliar.\n\nV8 and 64-bit Types\n-------------------\n\nInternally, V8 stores integers that will fit into a 32-bit space in a 32-bit\ninteger, and those that fall outside of this get put into double-precision\nfloating point numbers. This is problematic because FP numbers are imprecise.\nTo get around this, the methods in node-ffi that deal with 64-bit integers return\nstrings and can accept strings as parameters.\n\nCall Overhead\n-------------\n\nThere is non-trivial overhead associated with FFI calls. Comparing a hard-coded\nbinding version of `strtoul()` to an FFI version of `strtoul()` shows that the\nnative hard-coded binding is orders of magnitude faster. So don't just use the\nC version of a function just because it's faster. There's a significant cost in\nFFI calls, so make them worth it.\n\nLicense\n-------\n\nMIT License. See the `LICENSE` file.\n\n[v1apichanges]: https://github.com/rbranson/node-ffi/wiki/API-changes-from-v0.x-to-v1.x\n[tutorial]: https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial\n[ref-types]: https://github.com/TooTallNate/ref#built-in-types\n","_id":"ffi@1.1.0","dist":{"shasum":"ac88ac764f5a92162a74928fcd8f2b7d1c4b9ee9","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.1.0.tgz"},"_npmVersion":"1.1.57","_npmUser":{"name":"tootallnate","email":"nathan@tootallnate.net"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.1.1":{"name":"ffi","version":"1.1.1","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*"},"scripts":{"test":"node-gyp rebuild --directory test && mocha -gc --reporter spec","install":"node-gyp rebuild"},"repository":{"type":"git","url":"http://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"gypfile":true,"readme":"node-ffi\n========\n### Node.js Foreign Function Interface [![Build Status](https://secure.travis-ci.org/rbranson/node-ffi.png)](http://travis-ci.org/rbranson/node-ffi)\n\n`node-ffi` is a Node.js addon for loading and calling dynamic libraries using\npure JavaScript. It can be used to create bindings to native libraries without\nwriting any C++ code.\n\nIt also simplifies the augmentation of node.js with C code as it takes care of\nhandling the translation of types across JavaScript and C, which can add reams\nof boilerplate code to your otherwise simple C. See the `example/factorial`\nfor an example of this use case.\n\n**WARNING**: node-ffi assumes you know what you're doing. You can pretty easily\ncreate situations where you will segfault the interpreter and unless you've got\nC debugger skills, you probably won't know what's going on.\n\nExample\n-------\n\n``` js\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\nFor a more detailed introduction, see the [node-ffi tutorial page][tutorial].\n\nRequirements\n------------\n\n * Linux, OS X, Windows, or Solaris.\n * `libffi` comes bundled with node-ffi; it does *not* need to be installed on your system.\n * The current version is tested to run on node v0.6, v0.7, and v0.8.\n\nInstallation\n------------\n\nMake sure you've installed all the [necessary build\ntools](https://github.com/TooTallNate/node-gyp#installation) for your platform,\nthen invoke:\n\n``` bash\n$ npm install ffi\n```\n\nSource Install / Manual Compilation\n-----------------------------------\n\nTo compile from source it's easiest to use\n[`node-gyp`](https://github.com/TooTallNate/node-gyp):\n\n``` bash\n$ npm install -g node-gyp\n```\n\nNow you can compile `node-ffi`:\n\n``` bash\n$ git clone git://github.com/rbranson/node-ffi.git\n$ cd node-ffi\n$ node-gyp rebuild\n```\n\nTypes\n-----\n\nThe types that you specify in function declarations correspond to ref's types\nsystem. So [see its docs][ref-types] for\na reference if you are unfamiliar.\n\nV8 and 64-bit Types\n-------------------\n\nInternally, V8 stores integers that will fit into a 32-bit space in a 32-bit\ninteger, and those that fall outside of this get put into double-precision\nfloating point numbers. This is problematic because FP numbers are imprecise.\nTo get around this, the methods in node-ffi that deal with 64-bit integers return\nstrings and can accept strings as parameters.\n\nCall Overhead\n-------------\n\nThere is non-trivial overhead associated with FFI calls. Comparing a hard-coded\nbinding version of `strtoul()` to an FFI version of `strtoul()` shows that the\nnative hard-coded binding is orders of magnitude faster. So don't just use the\nC version of a function just because it's faster. There's a significant cost in\nFFI calls, so make them worth it.\n\nLicense\n-------\n\nMIT License. See the `LICENSE` file.\n\n[v1apichanges]: https://github.com/rbranson/node-ffi/wiki/API-changes-from-v0.x-to-v1.x\n[tutorial]: https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial\n[ref-types]: https://github.com/TooTallNate/ref#built-in-types\n","_id":"ffi@1.1.1","dist":{"shasum":"35a32bf9efccad54df24fa829a06efdbca2e2f11","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.1.1.tgz"},"_npmVersion":"1.1.57","_npmUser":{"name":"tootallnate","email":"nathan@tootallnate.net"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.1.2":{"name":"ffi","version":"1.1.2","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*"},"scripts":{"test":"node-gyp rebuild --directory test && mocha -gc --reporter spec","install":"node-gyp rebuild"},"repository":{"type":"git","url":"http://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"gypfile":true,"readme":"node-ffi\n========\n### Node.js Foreign Function Interface [![Build Status](https://secure.travis-ci.org/rbranson/node-ffi.png)](http://travis-ci.org/rbranson/node-ffi)\n\n`node-ffi` is a Node.js addon for loading and calling dynamic libraries using\npure JavaScript. It can be used to create bindings to native libraries without\nwriting any C++ code.\n\nIt also simplifies the augmentation of node.js with C code as it takes care of\nhandling the translation of types across JavaScript and C, which can add reams\nof boilerplate code to your otherwise simple C. See the `example/factorial`\nfor an example of this use case.\n\n**WARNING**: node-ffi assumes you know what you're doing. You can pretty easily\ncreate situations where you will segfault the interpreter and unless you've got\nC debugger skills, you probably won't know what's going on.\n\nExample\n-------\n\n``` js\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\nFor a more detailed introduction, see the [node-ffi tutorial page][tutorial].\n\nRequirements\n------------\n\n * Linux, OS X, Windows, or Solaris.\n * `libffi` comes bundled with node-ffi; it does *not* need to be installed on your system.\n * The current version is tested to run on node v0.6, v0.7, and v0.8.\n\nInstallation\n------------\n\nMake sure you've installed all the [necessary build\ntools](https://github.com/TooTallNate/node-gyp#installation) for your platform,\nthen invoke:\n\n``` bash\n$ npm install ffi\n```\n\nSource Install / Manual Compilation\n-----------------------------------\n\nTo compile from source it's easiest to use\n[`node-gyp`](https://github.com/TooTallNate/node-gyp):\n\n``` bash\n$ npm install -g node-gyp\n```\n\nNow you can compile `node-ffi`:\n\n``` bash\n$ git clone git://github.com/rbranson/node-ffi.git\n$ cd node-ffi\n$ node-gyp rebuild\n```\n\nTypes\n-----\n\nThe types that you specify in function declarations correspond to ref's types\nsystem. So [see its docs][ref-types] for\na reference if you are unfamiliar.\n\nV8 and 64-bit Types\n-------------------\n\nInternally, V8 stores integers that will fit into a 32-bit space in a 32-bit\ninteger, and those that fall outside of this get put into double-precision\nfloating point numbers. This is problematic because FP numbers are imprecise.\nTo get around this, the methods in node-ffi that deal with 64-bit integers return\nstrings and can accept strings as parameters.\n\nCall Overhead\n-------------\n\nThere is non-trivial overhead associated with FFI calls. Comparing a hard-coded\nbinding version of `strtoul()` to an FFI version of `strtoul()` shows that the\nnative hard-coded binding is orders of magnitude faster. So don't just use the\nC version of a function just because it's faster. There's a significant cost in\nFFI calls, so make them worth it.\n\nLicense\n-------\n\nMIT License. See the `LICENSE` file.\n\n[v1apichanges]: https://github.com/rbranson/node-ffi/wiki/API-changes-from-v0.x-to-v1.x\n[tutorial]: https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial\n[ref-types]: https://github.com/TooTallNate/ref#built-in-types\n","_id":"ffi@1.1.2","dist":{"shasum":"2051162c15b0c5fdfd150a19475d4a0536659d3a","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.1.2.tgz"},"_npmVersion":"1.1.57","_npmUser":{"name":"tootallnate","email":"nathan@tootallnate.net"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.1.3":{"name":"ffi","version":"1.1.3","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*"},"scripts":{"test":"node-gyp rebuild --directory test && mocha -gc --reporter spec","install":"node-gyp rebuild"},"repository":{"type":"git","url":"http://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"gypfile":true,"readme":"node-ffi\n========\n### Node.js Foreign Function Interface [![Build Status](https://secure.travis-ci.org/rbranson/node-ffi.png)](http://travis-ci.org/rbranson/node-ffi)\n\n`node-ffi` is a Node.js addon for loading and calling dynamic libraries using\npure JavaScript. It can be used to create bindings to native libraries without\nwriting any C++ code.\n\nIt also simplifies the augmentation of node.js with C code as it takes care of\nhandling the translation of types across JavaScript and C, which can add reams\nof boilerplate code to your otherwise simple C. See the `example/factorial`\nfor an example of this use case.\n\n**WARNING**: node-ffi assumes you know what you're doing. You can pretty easily\ncreate situations where you will segfault the interpreter and unless you've got\nC debugger skills, you probably won't know what's going on.\n\nExample\n-------\n\n``` js\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\nFor a more detailed introduction, see the [node-ffi tutorial page][tutorial].\n\nRequirements\n------------\n\n * Linux, OS X, Windows, or Solaris.\n * `libffi` comes bundled with node-ffi; it does *not* need to be installed on your system.\n * The current version is tested to run on node v0.6, v0.7, and v0.8.\n\nInstallation\n------------\n\nMake sure you've installed all the [necessary build\ntools](https://github.com/TooTallNate/node-gyp#installation) for your platform,\nthen invoke:\n\n``` bash\n$ npm install ffi\n```\n\nSource Install / Manual Compilation\n-----------------------------------\n\nTo compile from source it's easiest to use\n[`node-gyp`](https://github.com/TooTallNate/node-gyp):\n\n``` bash\n$ npm install -g node-gyp\n```\n\nNow you can compile `node-ffi`:\n\n``` bash\n$ git clone git://github.com/rbranson/node-ffi.git\n$ cd node-ffi\n$ node-gyp rebuild\n```\n\nTypes\n-----\n\nThe types that you specify in function declarations correspond to ref's types\nsystem. So [see its docs][ref-types] for\na reference if you are unfamiliar.\n\nV8 and 64-bit Types\n-------------------\n\nInternally, V8 stores integers that will fit into a 32-bit space in a 32-bit\ninteger, and those that fall outside of this get put into double-precision\nfloating point numbers. This is problematic because FP numbers are imprecise.\nTo get around this, the methods in node-ffi that deal with 64-bit integers return\nstrings and can accept strings as parameters.\n\nCall Overhead\n-------------\n\nThere is non-trivial overhead associated with FFI calls. Comparing a hard-coded\nbinding version of `strtoul()` to an FFI version of `strtoul()` shows that the\nnative hard-coded binding is orders of magnitude faster. So don't just use the\nC version of a function just because it's faster. There's a significant cost in\nFFI calls, so make them worth it.\n\nLicense\n-------\n\nMIT License. See the `LICENSE` file.\n\n[v1apichanges]: https://github.com/rbranson/node-ffi/wiki/API-changes-from-v0.x-to-v1.x\n[tutorial]: https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial\n[ref-types]: https://github.com/TooTallNate/ref#built-in-types\n","_id":"ffi@1.1.3","dist":{"shasum":"c755b0d359b14f60d46ed313a60bce942c9cba6b","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.1.3.tgz"},"_npmVersion":"1.1.62","_npmUser":{"name":"tootallnate","email":"nathan@tootallnate.net"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.2.0":{"name":"ffi","version":"1.2.0","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*","ref-array":"*"},"scripts":{"test":"node-gyp rebuild --directory test && mocha -gc --reporter spec","install":"node-gyp rebuild"},"repository":{"type":"git","url":"http://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"gypfile":true,"readme":"node-ffi\n========\n### Node.js Foreign Function Interface [![Build Status](https://secure.travis-ci.org/rbranson/node-ffi.png)](http://travis-ci.org/rbranson/node-ffi)\n\n`node-ffi` is a Node.js addon for loading and calling dynamic libraries using\npure JavaScript. It can be used to create bindings to native libraries without\nwriting any C++ code.\n\nIt also simplifies the augmentation of node.js with C code as it takes care of\nhandling the translation of types across JavaScript and C, which can add reams\nof boilerplate code to your otherwise simple C. See the `example/factorial`\nfor an example of this use case.\n\n**WARNING**: node-ffi assumes you know what you're doing. You can pretty easily\ncreate situations where you will segfault the interpreter and unless you've got\nC debugger skills, you probably won't know what's going on.\n\nExample\n-------\n\n``` js\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\nFor a more detailed introduction, see the [node-ffi tutorial page][tutorial].\n\nRequirements\n------------\n\n * Linux, OS X, Windows, or Solaris.\n * `libffi` comes bundled with node-ffi; it does *not* need to be installed on your system.\n * The current version is tested to run on node v0.6, v0.7, and v0.8.\n\nInstallation\n------------\n\nMake sure you've installed all the [necessary build\ntools](https://github.com/TooTallNate/node-gyp#installation) for your platform,\nthen invoke:\n\n``` bash\n$ npm install ffi\n```\n\nSource Install / Manual Compilation\n-----------------------------------\n\nTo compile from source it's easiest to use\n[`node-gyp`](https://github.com/TooTallNate/node-gyp):\n\n``` bash\n$ npm install -g node-gyp\n```\n\nNow you can compile `node-ffi`:\n\n``` bash\n$ git clone git://github.com/rbranson/node-ffi.git\n$ cd node-ffi\n$ node-gyp rebuild\n```\n\nTypes\n-----\n\nThe types that you specify in function declarations correspond to ref's types\nsystem. So [see its docs][ref-types] for\na reference if you are unfamiliar.\n\nV8 and 64-bit Types\n-------------------\n\nInternally, V8 stores integers that will fit into a 32-bit space in a 32-bit\ninteger, and those that fall outside of this get put into double-precision\nfloating point numbers. This is problematic because FP numbers are imprecise.\nTo get around this, the methods in node-ffi that deal with 64-bit integers return\nstrings and can accept strings as parameters.\n\nCall Overhead\n-------------\n\nThere is non-trivial overhead associated with FFI calls. Comparing a hard-coded\nbinding version of `strtoul()` to an FFI version of `strtoul()` shows that the\nnative hard-coded binding is orders of magnitude faster. So don't just use the\nC version of a function just because it's faster. There's a significant cost in\nFFI calls, so make them worth it.\n\nLicense\n-------\n\nMIT License. See the `LICENSE` file.\n\n[v1apichanges]: https://github.com/rbranson/node-ffi/wiki/API-changes-from-v0.x-to-v1.x\n[tutorial]: https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial\n[ref-types]: https://github.com/TooTallNate/ref#built-in-types\n","_id":"ffi@1.2.0","dist":{"shasum":"b96e6c32812c76523179ce2aadf99b031243cf84","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.2.0.tgz"},"_npmVersion":"1.1.62","_npmUser":{"name":"tootallnate","email":"nathan@tootallnate.net"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.2.1":{"name":"ffi","version":"1.2.1","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*","ref-array":"*"},"scripts":{"test":"node-gyp rebuild --directory test && mocha -gc --reporter spec","install":"node-gyp rebuild"},"repository":{"type":"git","url":"http://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"gypfile":true,"readme":"node-ffi\n========\n### Node.js Foreign Function Interface [![Build Status](https://secure.travis-ci.org/rbranson/node-ffi.png)](http://travis-ci.org/rbranson/node-ffi)\n\n`node-ffi` is a Node.js addon for loading and calling dynamic libraries using\npure JavaScript. It can be used to create bindings to native libraries without\nwriting any C++ code.\n\nIt also simplifies the augmentation of node.js with C code as it takes care of\nhandling the translation of types across JavaScript and C, which can add reams\nof boilerplate code to your otherwise simple C. See the `example/factorial`\nfor an example of this use case.\n\n**WARNING**: node-ffi assumes you know what you're doing. You can pretty easily\ncreate situations where you will segfault the interpreter and unless you've got\nC debugger skills, you probably won't know what's going on.\n\nExample\n-------\n\n``` js\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\nFor a more detailed introduction, see the [node-ffi tutorial page][tutorial].\n\nRequirements\n------------\n\n * Linux, OS X, Windows, or Solaris.\n * `libffi` comes bundled with node-ffi; it does *not* need to be installed on your system.\n * The current version is tested to run on node v0.6, v0.7, and v0.8.\n\nInstallation\n------------\n\nMake sure you've installed all the [necessary build\ntools](https://github.com/TooTallNate/node-gyp#installation) for your platform,\nthen invoke:\n\n``` bash\n$ npm install ffi\n```\n\nSource Install / Manual Compilation\n-----------------------------------\n\nTo compile from source it's easiest to use\n[`node-gyp`](https://github.com/TooTallNate/node-gyp):\n\n``` bash\n$ npm install -g node-gyp\n```\n\nNow you can compile `node-ffi`:\n\n``` bash\n$ git clone git://github.com/rbranson/node-ffi.git\n$ cd node-ffi\n$ node-gyp rebuild\n```\n\nTypes\n-----\n\nThe types that you specify in function declarations correspond to ref's types\nsystem. So [see its docs][ref-types] for\na reference if you are unfamiliar.\n\nV8 and 64-bit Types\n-------------------\n\nInternally, V8 stores integers that will fit into a 32-bit space in a 32-bit\ninteger, and those that fall outside of this get put into double-precision\nfloating point numbers. This is problematic because FP numbers are imprecise.\nTo get around this, the methods in node-ffi that deal with 64-bit integers return\nstrings and can accept strings as parameters.\n\nCall Overhead\n-------------\n\nThere is non-trivial overhead associated with FFI calls. Comparing a hard-coded\nbinding version of `strtoul()` to an FFI version of `strtoul()` shows that the\nnative hard-coded binding is orders of magnitude faster. So don't just use the\nC version of a function just because it's faster. There's a significant cost in\nFFI calls, so make them worth it.\n\nLicense\n-------\n\nMIT License. See the `LICENSE` file.\n\n[v1apichanges]: https://github.com/rbranson/node-ffi/wiki/API-changes-from-v0.x-to-v1.x\n[tutorial]: https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial\n[ref-types]: https://github.com/TooTallNate/ref#built-in-types\n","_id":"ffi@1.2.1","dist":{"shasum":"c5271819a72523673cccb31f3651e7dd92991acd","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.2.1.tgz"},"_npmVersion":"1.1.62","_npmUser":{"name":"tootallnate","email":"nathan@tootallnate.net"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.2.2":{"name":"ffi","version":"1.2.2","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*","ref-array":"*"},"scripts":{"test":"node-gyp rebuild --directory test && mocha -gc --reporter spec","install":"node-gyp rebuild"},"repository":{"type":"git","url":"http://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"gypfile":true,"readme":"node-ffi\n========\n### Node.js Foreign Function Interface [![Build Status](https://secure.travis-ci.org/rbranson/node-ffi.png)](http://travis-ci.org/rbranson/node-ffi)\n\n`node-ffi` is a Node.js addon for loading and calling dynamic libraries using\npure JavaScript. It can be used to create bindings to native libraries without\nwriting any C++ code.\n\nIt also simplifies the augmentation of node.js with C code as it takes care of\nhandling the translation of types across JavaScript and C, which can add reams\nof boilerplate code to your otherwise simple C. See the `example/factorial`\nfor an example of this use case.\n\n**WARNING**: node-ffi assumes you know what you're doing. You can pretty easily\ncreate situations where you will segfault the interpreter and unless you've got\nC debugger skills, you probably won't know what's going on.\n\nExample\n-------\n\n``` js\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\nFor a more detailed introduction, see the [node-ffi tutorial page][tutorial].\n\nRequirements\n------------\n\n * Linux, OS X, Windows, or Solaris.\n * `libffi` comes bundled with node-ffi; it does *not* need to be installed on your system.\n * The current version is tested to run on node v0.6, v0.7, and v0.8.\n\nInstallation\n------------\n\nMake sure you've installed all the [necessary build\ntools](https://github.com/TooTallNate/node-gyp#installation) for your platform,\nthen invoke:\n\n``` bash\n$ npm install ffi\n```\n\nSource Install / Manual Compilation\n-----------------------------------\n\nTo compile from source it's easiest to use\n[`node-gyp`](https://github.com/TooTallNate/node-gyp):\n\n``` bash\n$ npm install -g node-gyp\n```\n\nNow you can compile `node-ffi`:\n\n``` bash\n$ git clone git://github.com/rbranson/node-ffi.git\n$ cd node-ffi\n$ node-gyp rebuild\n```\n\nTypes\n-----\n\nThe types that you specify in function declarations correspond to ref's types\nsystem. So [see its docs][ref-types] for\na reference if you are unfamiliar.\n\nV8 and 64-bit Types\n-------------------\n\nInternally, V8 stores integers that will fit into a 32-bit space in a 32-bit\ninteger, and those that fall outside of this get put into double-precision\nfloating point numbers. This is problematic because FP numbers are imprecise.\nTo get around this, the methods in node-ffi that deal with 64-bit integers return\nstrings and can accept strings as parameters.\n\nCall Overhead\n-------------\n\nThere is non-trivial overhead associated with FFI calls. Comparing a hard-coded\nbinding version of `strtoul()` to an FFI version of `strtoul()` shows that the\nnative hard-coded binding is orders of magnitude faster. So don't just use the\nC version of a function just because it's faster. There's a significant cost in\nFFI calls, so make them worth it.\n\nLicense\n-------\n\nMIT License. See the `LICENSE` file.\n\n[v1apichanges]: https://github.com/rbranson/node-ffi/wiki/API-changes-from-v0.x-to-v1.x\n[tutorial]: https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial\n[ref-types]: https://github.com/TooTallNate/ref#built-in-types\n","readmeFilename":"README.md","_id":"ffi@1.2.2","dist":{"shasum":"59e28e4bb95625f71eb5ae7954bdc402a965e4ea","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.2.2.tgz"},"_npmVersion":"1.1.69","_npmUser":{"name":"tootallnate","email":"nathan@tootallnate.net"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}},"1.2.3":{"name":"ffi","version":"1.2.3","authors":["Rick Branson","Nathan Rajlich <nathan@tootallnate.net> (http://tootallnate.net)"],"description":"A foreign function interface (FFI) for Node.js","homepage":"http://github.com/rbranson/node-ffi","engines":{"node":">=0.6.0"},"main":"./lib/ffi","dependencies":{"bindings":"*","debug":"*","ref":"*","ref-struct":"*"},"devDependencies":{"expect.js":"*","mocha":"*","ref-array":"*"},"scripts":{"test":"node-gyp rebuild --directory test && mocha -gc --reporter spec","install":"node-gyp rebuild"},"repository":{"type":"git","url":"http://github.com/rbranson/node-ffi.git"},"bugs":{"url":"http://github.com/rbranson/node-ffi/issues"},"gypfile":true,"readme":"node-ffi\n========\n### Node.js Foreign Function Interface [![Build Status](https://secure.travis-ci.org/rbranson/node-ffi.png)](http://travis-ci.org/rbranson/node-ffi)\n\n`node-ffi` is a Node.js addon for loading and calling dynamic libraries using\npure JavaScript. It can be used to create bindings to native libraries without\nwriting any C++ code.\n\nIt also simplifies the augmentation of node.js with C code as it takes care of\nhandling the translation of types across JavaScript and C, which can add reams\nof boilerplate code to your otherwise simple C. See the `example/factorial`\nfor an example of this use case.\n\n**WARNING**: node-ffi assumes you know what you're doing. You can pretty easily\ncreate situations where you will segfault the interpreter and unless you've got\nC debugger skills, you probably won't know what's going on.\n\nExample\n-------\n\n``` js\nvar ffi = require('ffi');\n\nvar libm = ffi.Library('libm', {\n  'ceil': [ 'double', [ 'double' ] ]\n});\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, {\n  'atoi': [ 'int', [ 'string' ] ]\n});\ncurrent.atoi('1234'); // 1234\n```\n\nFor a more detailed introduction, see the [node-ffi tutorial page][tutorial].\n\nRequirements\n------------\n\n * Linux, OS X, Windows, or Solaris.\n * `libffi` comes bundled with node-ffi; it does *not* need to be installed on your system.\n * The current version is tested to run on node v0.6, v0.7, and v0.8.\n\nInstallation\n------------\n\nMake sure you've installed all the [necessary build\ntools](https://github.com/TooTallNate/node-gyp#installation) for your platform,\nthen invoke:\n\n``` bash\n$ npm install ffi\n```\n\nSource Install / Manual Compilation\n-----------------------------------\n\nTo compile from source it's easiest to use\n[`node-gyp`](https://github.com/TooTallNate/node-gyp):\n\n``` bash\n$ npm install -g node-gyp\n```\n\nNow you can compile `node-ffi`:\n\n``` bash\n$ git clone git://github.com/rbranson/node-ffi.git\n$ cd node-ffi\n$ node-gyp rebuild\n```\n\nTypes\n-----\n\nThe types that you specify in function declarations correspond to ref's types\nsystem. So [see its docs][ref-types] for\na reference if you are unfamiliar.\n\nV8 and 64-bit Types\n-------------------\n\nInternally, V8 stores integers that will fit into a 32-bit space in a 32-bit\ninteger, and those that fall outside of this get put into double-precision\nfloating point numbers. This is problematic because FP numbers are imprecise.\nTo get around this, the methods in node-ffi that deal with 64-bit integers return\nstrings and can accept strings as parameters.\n\nCall Overhead\n-------------\n\nThere is non-trivial overhead associated with FFI calls. Comparing a hard-coded\nbinding version of `strtoul()` to an FFI version of `strtoul()` shows that the\nnative hard-coded binding is orders of magnitude faster. So don't just use the\nC version of a function just because it's faster. There's a significant cost in\nFFI calls, so make them worth it.\n\nLicense\n-------\n\nMIT License. See the `LICENSE` file.\n\n[v1apichanges]: https://github.com/rbranson/node-ffi/wiki/API-changes-from-v0.x-to-v1.x\n[tutorial]: https://github.com/rbranson/node-ffi/wiki/Node-FFI-Tutorial\n[ref-types]: https://github.com/TooTallNate/ref#built-in-types\n","readmeFilename":"README.md","_id":"ffi@1.2.3","dist":{"shasum":"fead0ff4e159901c79ae67d89808bf4362514512","tarball":"http://registry.npmjs.org/ffi/-/ffi-1.2.3.tgz"},"_npmVersion":"1.1.69","_npmUser":{"name":"tootallnate","email":"nathan@tootallnate.net"},"maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"directories":{}}},"readme":"node-ffi\n========\n### Node.js Foreign Function Interface [![Build Status](https://secure.travis-ci.org/rbranson/node-ffi.png)](http://travis-ci.org/rbranson/node-ffi)\n\n`node-ffi` is a Node.js addon for loading and calling dynamic libraries using pure JavaScript. It can be used to create bindings to native libraries without writing any C++ code.\n\nIt also simplifies the augmentation of node.js with C code as it takes care of handling the translation of types across JavaScript and C, which can add reams of boilerplate code to your otherwise simple C. See the `example/factorial` for an example of this use case.\n\n**WARNING**: node-ffi assumes you know what you're doing. You can pretty easily create situations where you will segfault the interpreter and unless you've got C debugger skills, you probably won't know what's going on.\n\n# EXAMPLE\n\n``` js\nvar ffi = require('node-ffi');\n\nvar libm = ffi.Library('libm', { 'ceil': [ 'double', [ 'double' ] ] });\nlibm.ceil(1.5); // 2\n\n// You can also access just functions in the current process by passing a null\nvar current = ffi.Library(null, { 'atoi': [ 'int32', [ 'string' ] ] });\ncurrent.atoi('1234'); // 1234\n```\n\n# REQUIREMENTS\n\n * Linux, OS X, Windows, or Solaris.\n * `libffi` comes bundled with node-ffi, it does not need to be installed on your system.\n * The current version is tested to run on node 0.6.x.\n * If you need node 0.4.x support, use the `0.4` branch of node-ffi.\n\n# NPM INSTALL\n\n``` bash\n$ npm install node-ffi\n```\n\nMost popular operating systems have a pre-compiled binary that comes along with node-ffi, so most of the time you will not need to compile anything! (Unless of course you want to, then see below).\n\n# SOURCE INSTALL / MANUAL COMPILATION\n\nTo compile from source it's easiest to use\n[`node-gyp`](https://github.com/TooTallNate/node-gyp):\n\n``` bash\n$ npm install -g node-gyp\n```\n\nNow you can compile `node-ffi`:\n\n``` bash\n$ git clone git://github.com/rbranson/node-ffi.git\n$ cd node-ffi\n$ node-gyp configure build\n```\n\n# TYPES\n\n    int8        Signed 8-bit Integer\n    uint8       Unsigned 8-bit Integer\n    int16       Signed 16-bit Integer\n    uint16      Unsigned 16-bit Integer\n    int32       Signed 32-bit Integer\n    uint32      Unsigned 32-bit Integer\n    int64       Signed 64-bit Integer\n    uint64      Unsigned 64-bit Integer\n    float       Single Precision Floating Point Number (float)\n    double      Double Precision Floating Point Number (double)\n    pointer     Pointer Type\n    string      Null-Terminated String (char *)\n\nIn addition to the basic types, there are type aliases for common C types.\n\n    byte        unsigned char\n    char        char\n    uchar       unsigned char\n    short       short\n    ushort      unsigned short\n    int         int\n    uint        unsigned int\n    long        long\n    ulong       unsigned long\n    longlong    long\n    ulonglong   unsigned long long\n    size_t      platform-dependent, usually pointer size\n\n# V8 and 64-bit Types\n\nInternally, V8 stores integers that will fit into a 32-bit space in a 32-bit integer, and those that fall outside of this get put into double-precision floating point numbers. This is problematic because FP numbers are imprecise. To get around this, the methods in node-ffi that deal with 64-bit integers return strings and can accept strings as parameters.\n\n# Call Overhead\n\nThere is non-trivial overhead associated with FFI calls. Comparing a hard-coded binding version of `strtoul()` to an FFI version of `strtoul()` shows that the native hard-coded binding is 5x faster. So don't just use the C version of a function just because it's faster. There's a significant cost in FFI calls, so make them worth it.\n\n# LICENSE\n\nMIT License. See the `LICENSE` file.\n\n","maintainers":[{"name":"tootallnate","email":"nathan@tootallnate.net"}],"time":{"1.0.0":"2012-05-31T21:15:58.017Z","1.0.1":"2012-06-14T03:40:46.164Z","1.0.3":"2012-07-10T01:01:53.771Z","1.0.4":"2012-07-13T06:52:18.735Z","1.0.5":"2012-07-22T22:17:20.310Z","1.0.6":"2012-07-22T23:33:26.173Z","1.0.7":"2012-08-03T18:31:59.605Z","1.1.0":"2012-09-12T03:18:30.863Z","1.1.1":"2012-09-16T20:50:08.852Z","1.1.2":"2012-09-17T00:31:00.197Z","1.1.3":"2012-09-26T00:17:11.430Z","1.2.0":"2012-10-13T17:54:57.231Z","1.2.1":"2012-12-15T19:49:30.867Z","1.2.2":"2012-12-15T21:59:39.907Z","1.2.3":"2012-12-20T22:10:20.031Z"},"repository":{"type":"git","url":"http://github.com/rbranson/node-ffi.git"},"_etag":"\"36WOTDUNAO0CI9XL00838BB6A\""}