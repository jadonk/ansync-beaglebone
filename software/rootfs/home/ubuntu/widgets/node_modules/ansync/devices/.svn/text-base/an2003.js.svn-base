var util   = require("util"),
    device = require("./basedevice");

function AN2003(serial, alias, logger) {
    AN2003.super_.call(this,
                       serial,   // Serial number, from args if provided
                       alias,    // Device alias, from args if provided
                       "AN2003", // Model number
                       1,        // Minimum channel, as seen from userspace
                       16,       // Maximum channel, as seen from userspace
                       logger);  // Logger (singleton), from args if provided
}
util.inherits(AN2003, device.BaseDevice);

AN2003.prototype.init = function() {
    var rc = new Error("Unknown error");

    rc = this.preInit();
    if (rc instanceof Error) {
        return rc;
    }

    this.boardHandle = this.libvita.AN2003_new(this.portHandle, 0);
    if (this.boardHandle <= 0) {
        return new Error("Failed to bind driver to " + this.getIdentifier());
    }

    // Set all pins as input
    rc = this.libvita.AN2003_setDirections(this.boardHandle, 0xFFFF);
    if (rc < 0) {
        this.close();
        return new Error("Failed to set directions on " + this.getIdentifier());
    }

    this.logger.info("done.");
    return 0;
}

AN2003.prototype.setChannel = function(channel, power) {
    var mask;
    var data;
    var rc = -1;

    if (channel < this.minChannel || channel > this.maxChannel) {
        return new Error("Invalid channel for " + this.getIdentifier() + ".  Valid channels are " + this.minChannel + " to " + this.maxChannel);
    }
    if (power < 0 || power > 1) {
        return new Error("Invalid channel value for " + this.getIdentifier() + " Valid values are 1 and 0");
    }

    mask = this.libvita.AN2003_getInputs(this.boardHandle);

    if (power) {
        mask &= ~(1 << channel - 1); // Channel 1 is actually channel 0, etc.
    } else {
        mask |= (1 << channel - 1);
    }

    rc = this.libvita.AN2003_setOutputs(this.boardHandle, mask);

    if (rc < 0) {
        return new Error("Failed to turn " + (power? "on " : "off ") + "channel " + channel + " on " + this.getIdentifier());
    } else {
        data = {
            type: "Digital",
            value: power
        };

        this.emit("ansync-data", this.serial, this.alias, this.model, channel, data);
    }
}

AN2003.prototype.getChannel = function(channel) {
    var mask;
    var rc = -1;

    if (channel < this.minChannel || channel > this.maxChannel) {
        return new Error("Invalid channel for " + this.getIdentifier() + ".  Valid channels are " + this.minChannel + " to " + this.maxChannel);
    }

    mask = this.libvita.AN2003_getInputs(this.boardHandle);

    if (mask & (1 << channel - 1)) {
        return false;
    } else {
        return true;
    }
}

AN2003.prototype.button = function(channel, power) {
    this.setChannel(channel, power);
}

AN2003.prototype.poll = function(channel, gain) {
    var power = -1;
    var data  = {};

    if (channel < this.minChannel || channel > this.maxChannel) {
        return new Error("Invalid channel for " + this.getIdentifier() + ".  Valid channels are " + this.minChannel + " to " + this.maxChannel);
    }

    power = this.getChannel(channel);

    data = {
        type: "Digital",
        value: power,
        units: "N/A"
    };
    this.emit("ansync-data", this.serial, this.alias, this.model, channel, data);
}

exports.AN2003 = AN2003;
