var util   = require("util"),
    device = require("./basedevice");

function AN2016(serial, alias, logger) {
    AN2016.super_.call(this, serial, alias, "AN2016", 1, 5, logger);
}
util.inherits(AN2016, device.BaseDevice);

AN2016.prototype.init = function() {
    var rc = new Error("Unknown error");

    rc = this.preInit();
    if (rc instanceof Error) {
        return rc;
    }

    this.boardHandle = this.libvita.AN2016_new(this.portHandle, 0);
    if (this.boardHandle <= 0) {
        return new Error("Failed to bind driver to " + this.getIdentifier());
    }

    this.logger.info("done.");
    return 0;
}

AN2016.prototype.getVoltage = function(channel, gain) {
    var rc = -1;
    var voltage;
    var stat = 0x00;
    var conversionTimer;
    var data;
    var _this = this;

    if((rc = this.libvita.AN2016_requestInput(this.boardHandle, parseInt(channel), parseInt(gain))) < 0) {
        console.error("Error getting voltage from " + this.getIdentifier() + " on channel " + channel);
    } else {
        conversionTimer = setInterval(function() {
            stat = _this.libvita.AN2016_getStatus(_this.boardHandle,  parseInt(channel));
            if (stat & 0x80) {
                clearInterval(conversionTimer);

                setTimeout(function() {
                    if((voltage = _this.libvita.AN2016_getInput(_this.boardHandle, parseInt(channel))) < 0) {
                        console.error("Error getting voltage from " + _this.getIdentifier() + " on channel " + channel);
                    } else {
                        data = {
                            type: "Analog",
                            value: parseFloat(voltage.toFixed(4)),
                            units: "Volts"
                        };
                        _this.logger.debug("Voltage from " + _this.getIdentifier() + ": " + voltage.toFixed(4));
                        _this.emit("ansync-data", _this.serial, _this.alias, _this.model, channel, data);
                    }
                }, 80);
            }
        }, 50);
    }
}

AN2016.prototype.getChannel = function(channel, gain) {
    if (channel < this.minChannel || channel > this.maxChannel) {
        return new Error("Invalid channel for " + this.getIdentifier() + ".  Valid channels are " + this.minChannel + " to " + this.maxChannel);
    }
    if (isNaN(gain) || gain < 1 || gain > 2 || parseInt(gain) != parseFloat(gain)) {
        return new Error("Invalid gain for " + this.getIdentifier() + ": " + gain + ".  Valid gains are 1 and 2.");
    }

    this.getVoltage(channel, gain);
}

AN2016.prototype.poll = function(channel, gain) {
    if (channel < this.minChannel || channel > this.maxChannel) {
        return new Error("Invalid channel for " + this.getIdentifier() + ".  Valid channels are " + this.minChannel + " to " + this.maxChannel);
    }

    this.getChannel(channel, gain);
}

exports.AN2016 = AN2016;
