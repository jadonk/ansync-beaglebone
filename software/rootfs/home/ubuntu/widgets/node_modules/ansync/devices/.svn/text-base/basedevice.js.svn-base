var util     = require("util"),
    ffi      = require("ffi"),
    ref      = require("ref"),
    os       = require("os"),
    events   = require("events"),
    resolver = require("./vitaresolver");

function BaseDevice(serial, alias, model, minChannel, maxChannel, logger) {
    var lib;

    this.serial = serial;
    this.alias = alias;
    this.model = model;
    this.minChannel = minChannel;
    this.maxChannel = maxChannel;
    this.portHandle = null;
    this.boardHandle = null;
    this.logger = logger;

    if (os.platform() == "win32") {
        lib = __dirname + "/../lib/libvita/libvita.dll"
    } else {
        lib = __dirname + "/../lib/libvita/libvita.so"
    }

    this.parameters = {
        serial: serial,
        alias: alias,
        model: model,
        minChannel: minChannel,
        maxChannel: maxChannel
    }

    this.libvita = new ffi.Library(lib, resolver.getVitaFunctions(model));

    events.EventEmitter.call(this);
}
util.inherits(BaseDevice, events.EventEmitter);

/* Note that we must follow the below syntax for defining the class" prototype.
 * Using JSON-style syntax (e.g., BaseDevice.prototype = { foo: function() . . . }) with
 * util.inherits will overwrite the prototype inherited from BaseDevice"s
 * superclass.
 */
BaseDevice.prototype.preInit = function() {
    var buf = ref.alloc(ref.types.CString);
    var rc = -1;

    this.logger.info("Attempting to connect to " + this.model);

    this.portHandle = this.libvita.USBLIB_new(0x165F, 0, this.serial, this.model);
    if (this.portHandle <= 0) {
        return new Error("Failed to connect to " + this.getIdentifier() + ".  Is it plugged in?");
    }

    if (!this.model) {
        rc = this.libvita.ANUSB_getProductString(this.portHandle, buf);
        if (rc < 0) {
            this.close();
            return new Error("Failed to read model from " + this.getIdentifier());
        } else {
            this.model = ref.readCString(buf, 0);
        }
    }

    if (!this.serial) {
        rc = this.libvita.ANUSB_getSerial(this.portHandle, 0x1, buf)
        if (rc < 0) {
            this.close();
            return new Error("Failed to read serial number from " + this.getIdentifier());
        } else {
            this.serial = ref.readCString(buf, 0);
        }
    }

    return 0;
}

BaseDevice.prototype.getIdentifier = function() {
    var id = this.model;
    var and = " with ";

    if (this.serial) {
        id += " with serial " + this.serial;
        and = " and ";
    }
    if (this.alias) {
        id += and + "alias \"" + this.alias + "\"";
    }

    return id;
}
BaseDevice.prototype.close = function() {
    var rc;

    if (this.portHandle && this.portHandle > 0) {
        rc = this.libvita.USBLIB_close(this.portHandle);
    }

    this.boardHandle = null;
    this.portHandle = null;

    if (rc < 0) {
        return new Error("Exception occured while trying to close device handle.  Return code " + rc);
    }
}

BaseDevice.prototype.getParameter = function(key) {
    return this.parameters[key];
}

BaseDevice.prototype.setParameter = function(key, value) {
    this.parameter[key] = value;
}

// Abstract functions to be overridden by deriving objects
BaseDevice.prototype.button     = function() {}
BaseDevice.prototype.poll       = function() {}
BaseDevice.prototype.slider     = function() {}
BaseDevice.prototype.getChannel = function() { return false; }
BaseDevice.prototype.setChannel = function() { return false; }

exports.BaseDevice = BaseDevice;
