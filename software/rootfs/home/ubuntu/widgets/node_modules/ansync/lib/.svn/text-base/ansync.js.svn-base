var devices   = require("../devices/devices.js"),
    Logger   = require("./logger"),
    ffi      = require("ffi"),
    os       = require("os"),
    fs       = require("fs");

var boundDevices = {}; // List of bound devices
var deviceConfig = {}; // Config file, in JSON form
var vitaInitialized = false;
var io;
var logger;
var polls = {};

initVita = function() {
    var lib = __dirname + "/libvita/";
    var libvita = null;
    var rc;
    var error = new Error("Unknown error");

    if (!vitaInitialized) {
        if (os.platform() == "win32") {
            lib += "libvita.dll";
        } else {
            lib += "libvita.so";
        }

        libvita = new ffi.Library(lib, { "vitaInit": ["int", []] });

        rc = libvita.vitaInit();
        if (rc < 0) {
            error = new Error("Failed to initialize libvita.  Return code: " + rc);
        } else {
            error = null;
            vitaInitialized = true;
        }
    } else {
        error = null;
    }

    return error;
}

bindDevice = function(serial, alias, model) {
    var device = null;
    var err = new Error("Unknown error");
    var _this = this;

    device = devices.getDevice(serial, alias, model, logger);
    if (device instanceof Error) {
        return device;
    } else {
        err = device.init();

        if (err) {
            return err;
        } else if (err < 0) {
            return new Error("Exception while initializing " + model.toUpperCase() + (serial? " with serial " + serial : "") + (alias? " with alias " + alias : "") + ". Return code: " + rc);
        } else {
            device.on("ansync-data", function(serial, alias, model, channel, data) {
                io.sockets.in(model + "." + channel).emit("ansync-data", null, null, model, channel, data);

                if (serial) {
                    io.sockets.in(serial + "." + channel).emit("ansync-data", serial, null, model, channel, data);
                }
                if (alias) {
                    io.sockets.in(alias + "." + channel).emit("ansync-data", null, alias, model, channel, data);
                }
            });

            return device;
        }
    }
}

unbindDevice = function(dev) {
    if (boundDevices[dev]) {
        serial = boundDevices[dev].serial;
        alias = boundDevices[dev].alias;
        model = boundDevices[dev].model;

        boundDevices[dev].close();

        boundDevices[serial] = null;
        if (boundDevices[alias]) {
            boundDevices[alias] = null;
        }
        if (boundDevices[model]) {
            boundDevices[model] = null;
        }
    }
}

loadConfigFile = function() {
    var device = {};
    var error = new Error("Unknown Error");

    fs.readFile(__dirname + "/../../../devices.json", function(err, data) { // TODO there's probably a better way to resolve this filename
        if (err) {
            logger.warn("Not loading device configuration file: " + err);
        } else {
            logger.info("Loading devices from configuration file . . . ");

            deviceConfig = JSON.parse(data);

            for (alias in deviceConfig) {
                error = getDevice(deviceConfig[alias].serial, alias, deviceConfig[alias].model, device);
            }
        }
    });
}

getDevice = function(serial, alias, model) {
    var dev = null;

    if (serial && typeof(serial) === "string") {
        if (boundDevices[serial]) {
            return boundDevices[serial];
        } else {
            if (alias && boundDevices[alias]) {
                return new Error("Alias already bound to " + boundDevices[alias].model + " with serial " + boundDevices[alias].serial);
            } else {
                if (model && model.match(/^AN\d{4}$/i)) {
                    dev = this.bindDevice(serial, alias, model);

                    if (!(dev instanceof Error)) {
                        if (dev.serial) {
                            boundDevices[dev.serial] = dev;
                        }
                        if (dev.alias) {
                            boundDevices[dev.alias] = dev;
                        }
                        if (!dev.model) {
                            boundDevices[dev.model] = dev;
                        }
                    }

                    return dev;
                } else {
                    return new Error("Invalid model: " + model);
                }
            }
        }
    } else if (alias && typeof(alias) === "string") {
        if (boundDevices[alias]) {
            return boundDevices[alias];
        } else {
            if (deviceConfig[alias]) {
                for (device in boundDevices) {
                    if (deviceConfig[alias].serial == boundDevices[device].serial) {
                        boundDevices[alias] = boundDevices[device];
                        return boundDevices[device];
                    }
                }
                dev = this.bindDevice(deviceConfig[alias].serial, alias, deviceConfig[alias].model);

                if (!(dev instanceof Error)) {
                    if (dev.serial) {
                        boundDevices[dev.serial] = dev;
                    }
                    if (!boundDevices[dev.model]) {
                        boundDevices[dev.model] = dev;
                    }
                    boundDevices[dev.alias] = dev;
                }

                return dev;
            } else {
                return new Error("No devices found for alias " + alias + "");
            }
        }
    } else if (model && typeof(model) === "string" && model.match(/^AN\d{4}$/i)) {
        for (device in boundDevices) {
            if (model == boundDevices[device].model) {
                return boundDevices[device];
            }
        }
        dev = this.bindDevice(null, null, model, dev);

        if (!(dev instanceof Error)) {
            if (dev.serial) {
                boundDevices[dev.serial] = dev;
            }
            if (!boundDevices[dev.model]) {
                boundDevices[dev.model] = dev;
            }
        }

        return dev;
    } else {
        return new Error("Invalid model " + model);
    }
}

setPoll = function(id, device, channel, gain, time) {
    var interval;

    if (gain && (isNaN(gain) || parseInt(gain) != parseFloat(gain) || gain < 1)) {
        return new Error("Invalid gain: " + gain);
    }
    if (isNaN(time) || parseInt(time) != parseFloat(time) || time < 10) {
        return new Error("Invalid time: " + time);
    }
    if (!device) {
        return new Error("Invalid device: " + device);
    }

    if (!polls[id]) {
        polls[id] = [];
    }

    interval = setInterval(function() {
        device.poll(parseInt(channel), parseInt(gain));
    }, time);

    polls[id].push(interval);

    return 0;
}

init = function(socketio, options) {
    var error = new Error("Unknown error");

    logger = new Logger();
    if (options["log level"] >= 0 && options["log level"] <= 3) {
        logger.level = options["log level"];
    }

    error = initVita();
    if (error) {
        throw error;
    }

    loadConfigFile();
    io = socketio;
}

bind = function(socket) {
    var device = null;
    var channelValue = false;
    var min;
    var max;
    var error = new Error("Unknown error");

    socket.emit("ready");

    socket.on("digital", function(serial, alias, model, channel, callback) {
        device = getDevice(serial, alias, model);
        if (!(device instanceof Error)) {
            if (devices.channelArrayValidForModel(device.model, channel.split(" "))) {
                error = "";
                channelValue = device.getChannel(channel); // TODO Maybe we shouldn't be doing this; might be weird for non-bursa boxes.
            } else {
                error = new Error("Channel " + channel + " not valid for model " + model)
                logger.error(error);
            }
        } else {
            error = device;
        }

        callback(error.toString(), channelValue);
    });

    socket.on("digital_out", function(serial, alias, model, channel, time, callback) {
        device = getDevice(serial, alias, model);
        if (!(device instanceof Error)) {
            if (devices.channelValidForModel(device.model, channel)) {
                if (time) {
                    error = setPoll(socket.id, device, channel, 0, time);
                    if (!(error instanceof Error)) {
                        error = "";
                    }
                } else {
                    error = "";
                    channelValue = device.getChannel(channel); // TODO Maybe we shouldn't be doing this; might be weird for non-bursa boxes.
                }
            } else {
                error = new Error("Channel " + channel + " not valid for model " + model)
                logger.error(error);
            }
        } else {
            error = device;
        }

        callback(error.toString(), channelValue);
    });

    socket.on("analog_out", function(serial, alias, model, channel, gain, time, callback) {
        device = getDevice(serial, alias, model);
        if (!(device instanceof Error)) {
            if (devices.channelValidForModel(device.model, channel)) {
                error = setPoll(socket.id, device, channel, gain, time);
                if (!(error instanceof Error)) {
                    error = "";
                }
            } else {
                error = new Error("Channel " + channel + " not valid for model " + model)
                logger.error(error);
            }
        } else {
            error = device;
        }

        callback(error.toString());
    });

    socket.on("range", function(serial, alias, model, channel, min, max, callback) {
        device = getDevice(serial, alias, model);
        if (!(device instanceof Error)) {
            if (devices.channelValidForModel(device.model, channel)) {
                if (rangeValidForModel(device.model, channel, min, max)) {
                    error = "";
                    min = device.getParameter("minValue");
                    max = device.getParameter("maxValue");
                    channelValue = device.getChannel(channel);
                } else {
                    error = new Error("Channel " + channel + " not valid for model " + model)
                    logger.error(error);
                }
            } else {
                error = new Error("Channel " + channel + " not valid for model " + model)
                logger.error(error);
            }
        } else {
            error = device;
        }

        callback(error.toString(), min, max, channelValue);
    });

    socket.on("button", function(serial, alias, model, channel, state) {
        device = getDevice(serial, alias, model);
        if (!(device instanceof Error)) {
            error = device.button(channel, state);
            if (error) {
                logger.error(error);
                unbindDevice(device); // TODO this will invalidate the device whenever an error occurs.  Accept an option to disable it.
            }
        } else {
            logger.error(error);
        }
    });

    socket.on("slider", function(serial, alias, model, channel, value) {
        device = getDevice(serial, alias, model);
        if (!(device instanceof Error)) {
            error = device.setChannel(channel, value);
            if (error) {
                logger.error(error);
                unbindDevice(device); // TODO this will invalidate the device whenever an error occurs.  Accept an option to disable it.
            }
        } else {
            logger.error(error);
        }
    });

    socket.on("join", function(room) {
        socket.join(room);
    });

    socket.on("disconnect", function() {
        if (polls[socket.id]) {
            // Client just disconnected, so clear polls
            for (var i = 0; i < polls[socket.id].length; i++) {
                clearInterval(polls[socket.id][i]);
            }

            delete polls[socket.id];
        }
    })
}

quit = function() {
    for (dev in boundDevices) {
        unbindDevice(dev);
    }
}

module.exports.version   = "0.5.0";
module.exports.init      = init;
module.exports.bind      = bind;
module.exports.quit      = quit;
module.exports.getDevice = getDevice;
