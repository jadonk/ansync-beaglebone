var addon = exports.addon = require('./index')
	,async = require('async')
	,_ = require('underscore')
	,tests = require('./test2')
	,fs = require('fs');

var user = 'konstantin'
	,debug = false;

var tester = {
	testArr: [],
	init: function(callback) {
		var self = this
			,initArr = [];

		var args = process.argv;
		if (args.length > 2) {
			args.shift();
			args.shift();
			args.forEach(function(item) {
				if (item == '-d') debug = true;
				else self.testArr.push(item);
			});
		}

		if (!self.testArr.length) self.testArr = _(tests).keys();

		for (var i = 0; i < self.testArr.length; i++) {
			var test = tests[self.testArr[i]];
			initArr.push(test.init);
			_.defaults(test, util);
			_.bindAll(test);
		}

		async.parallel(initArr, function(err, results) {
			if (err) return callback(err);
			return callback(null, results);
		});
	},
	run: function(callback) {
		var self = this
			,object = {};

		for (var i = 0; i < self.testArr.length; i++) {
			var name = self.testArr[i];
			var test = tests[name];
			if (test.sync && (self.testArr.indexOf(test.sync) != -1)) {
				object[name] = [];
				object[name].push(test.sync);
				object[name].push(test.run);
			} else object[name] = test.run;
			//runArr.push(test.run);
		}

		async.auto(object, function(err, results) {
			if (err) return callback(err);

			data = _.flatten(results);

			for (var i = 0; i < data.length; i++) {
				var report = data[i].report;
				var results = data[i].results;

				self.append('----------------' + data[i].name + ' Report----------------');
				self.append('Description: ' + data[i].description);
				self.append(report);

				console.log("\t" + data[i].name + " Results:");
				console.log(results);
			}
			printReport.apply(self);
			return callback(null);
		});
	},
	close: function(callback) {
		var self = this
			,closeArr = [];

		for (var i = 0; i < self.testArr.length; i++) {
			closeArr.push(tests[self.testArr[i]].close);
		}

		async.parallel(closeArr, function(err, results) {
			if (err) return callback(err);
			console.log('done');
			return callback(null);
		});
	}
};

var util = {
	report: '',
	results: '',
	name: '',
	description: '',

	append: function(string) {
		this.report += string + "\n";
		if (debug) console.log(string);
	},

	appendResults: function(string) {
		this.append("\t**" + string);
		this.results += "\t**" + string + "\n";
	},

	// convert to milliseconds
	toMs: function(arr) {
		var time = arr[0] * 1000 + arr[1] / 1000000;
		return time;
	},

	// ignores first value
	averageArr: function(arr) {
		var total = 0;
		for (var i = 1; i < arr.length; i++) {
			total += arr[i];
		}
		return total / (arr.length - 1);
	},

	inRange: function(data, output, voltMargin) {
		return (data < (output + voltMargin * output) && data > (output - voltMargin * output)); 
	}
};

var printReport = function() {
	var self = this;
	process.setuid(user);
	fs.writeFile('testReport.txt', self.report, function(err) {
		if (err) console.log(err);
	});
}

_.defaults(tester, util);
_.bindAll(tester);

// programs starts here
async.series([
	tester.init
	,tester.run
	,tester.close
	], function(err, results) {
		if (err) console.log(err);
	}
);

