var addon = require('./index');
var async = require('async');
var test1Num = 10;
var test2Num = 93;
var channel = 1;
var group = 1;
var currentOutput = 1;
var agent1Count = 0;
var agent2Count = 0;
var agent1Pass = 0;
var agent2Pass = 0;
var agent2003;
var agent2024;
var voltMargin = .11;
var stopped = false;

var init = function(callback) {
	addon.open('usb:CLASS_AN2003/88888888', function(err, result) {
		if (err) return callback('Error:an2003 failed to open, ' + err);
		an2003 = result;
		addon.open('usb:CLASS_AN2012/66666666', function(err, result) {
			if (err) return callback('Error:an2012 failed to open, ' + err);
			an2012 = result;
			addon.open('usb:CLASS_AN2015/77777777', function(err, result) {
				if (err) return callback('Error:an2015 failed to open, ' + err);
				an2015 = result;
				addon.open('usb:CLASS_AN2024/00108158', function(err, result) {
					if (err) return callback('Error:an2024 failed to open, ' + err);
					an2024 = result;
					callback(null);
				});
			});
		});
	});
}

var test1 = function(pass, output, callback) {
	an2015.setOutputs(group, channel, output, function(err) {
		if (err) return callback("Error: failed to set output on 2015, " + err);
		currentOutput = output;

		setTimeout(function() {
			an2003.getInputs(group, channel, function(err, data) {
				if (err) return callback("Error: can't get input on 2003, " + err);
				console.log("\tGot input on 2003: %d, original: %d", data, output);
				if (data != output) {
					console.log("Error: inputs on 2003 wrong");
					return callback(null, pass);
				} else return callback(null, ++pass);
			});
		}, 100);
	});
}

var test2 = function(pass, output, callback) {
	var pass1 = false;
	var pass2 = false;
	an2012.setOutputs(1, 1, output, function(err) {
		if (err) return callback("Error: failed to set output on 2012 ch1, " + err);
		an2012.setOutputs(1, 2, output, function(err) {
			if (err) return callback("Error: failed to set output on 2012 ch2, " + err);
			//setTimeout(function() {
				an2024.getInputs(2, 1, function(err, data) {
					if (err) return callback("Error: can't get input on 2024 ch1, " + err);
					console.log("\tGot input on 2024: %d, original: %d", data, output);

					if (data > (output + voltMargin * output) || data < (output - voltMargin * output)) {
						console.log("Error: inputs on 2024 ch1 out of bounds");
					} else pass1 = true;

					an2024.getInputs(2, 2, function(err, data) {
						if (err) return callback("Error: can't get input on 2024 ch2, " + err);
						console.log("\tGot input on 2024: %d, original: %d", data, output);

						if (data > (output + voltMargin * output) || data < (output - voltMargin * output)) {
							console.log("Error: inputs on 2024 ch2 out of bounds");
						} else pass2 = true;

						if (pass1 && pass2) return callback(null, ++pass);
						else return callback(null, pass);
					});
			});
				//}, 100);
		});
	});
}

var close = function() {
	an2003.close();
	an2015.close();
	an2012.close();
	an2024.close();
}

init(function(err) {
	if (err) return console.log(err);

	an2003.setProperty(group, 0, 1, 0xffff, function(err) {
		if (err) console.log('Error: cant set property on 2003, ' + err);
		else {
			var output = 0;
			var outputArr = [];
			var pass = 0;
			for (var i = 0; i < test1Num; i++) {
				output = output? 0: 1;
				outputArr.push(output);
			}

			async.reduce(outputArr, pass, test1, function(err, result) {
				if (err) console.log(err);
				else {
					stopped = true;
					console.log("\ttest1 results: %d passed out of %d.", result, test1Num);
					console.log("\ttest1agent results: %d passed out of %d.", agent1Pass, agent1Count);
				}
			});

			an2003.startAgent(group, channel, 0, function(err, data, agentId) {
				 if (err) console.log("Error: agent on 2003, " + err);
				 else {
					 console.log("\tAgent 1 data: " + data);
					 agent1Count++;
					 if (currentOutput == data) {
						 agent1Pass++;
					}
					if (stopped) {
						console.log('stopped****************************');
						an2003.stopAgent(agentId);
					}
				 }
			});
		}
	});

	var outputVoltArr = [];
	for (var i = 0; i < test2Num; i++) {
		outputVoltArr.push(i * 10 + 70);
	}

	async.reduce(outputVoltArr, 0, test2, function(err, result) {
		if (err) console.log(err);
		else {
			console.log("\ttest2 results: %d passed out of %d.", result, test2Num);

			an2024.setOutputs(1, 1, 100, function(err) {
				if (err) console.log("Error: setting outputs on 2024, " + err);
				currentVoltage = 100;
				an2024.startAgent(2, 4, 100, function(err, data, agentId) {
					agent2024 = agentId;
					 if (err) console.log("Error: agent on 2024, " + err);
					 else {
						 console.log("\tAgent 2 data: " + data);
						 agent2Count++;
						 if (currentVoltage > (data - voltMargin) || currentVoltage < (data - voltMargin)) {
							 agent2Pass++;
						}
					 }
				});
			});
			an2024.setOutputs(1, 1, 200, function(err) {
				if (err) console.log("Error: setting outputs on 2024, " + err);
				currentVoltage = 200;
				setTimeout(function() {
					an2024.setOutputs(1, 1, 250, function(err) {
						if (err) console.log("Error: setting outputs on 2024, " + err);
						currentVoltage = 250;
						setTimeout(function() {
							an2024.stopAgent(agent2024);
							console.log("\ttest2agent results: %d passed out of %d.", agent2Pass, agent2Count);
							close();
						}, 500);
					});
				}, 500);
			});
		}
	});

});
