#include <queue>
#include <node.h>
#include <v8.h>
#include "uv.h"
#include "vita.h"
#include "vterror.h"

struct Baton {
    // Extract callback automatically as the last parameter
    // and VitaContext from the first internal pointer of This().
    Baton(const v8::Arguments& args) {
        v8::Handle<v8::Value> last = args[args.Length()-1];
        if (last != v8::Undefined() && last->IsFunction()) {
            callback = v8::Persistent<v8::Value>::New(last);
        } else {
            callback = v8::Persistent<v8::Value>::New(v8::Undefined());
        }
    }

    ~Baton() {
        this->callback.Dispose();
    }

    void call() {
        const unsigned argc = 3;

        v8::Handle<v8::Value> argv[argc];
        
        if (this->rc >= 0) {
            argv[0] = v8::Undefined();
            argv[1] = v8::Integer::New(this->data);
            argv[2] = v8::Integer::New(this->rc);
        } else {
            argv[0] = v8::Exception::Error( v8::String::Concat(
                v8::String::New("libvita failure: "), 
                v8::String::New(vita_error_str(this->rc))));
            argv[1] = v8::Undefined();
            argv[2] = v8::Undefined();
        }

        if (this->callback->IsFunction()) {
            v8::Function::Cast(*(this->callback))->Call(v8::Context::GetCurrent()->Global(), argc, argv);
        }
    }

    v8::Persistent<v8::Value> callback;

    int group;
    int channel;
    int property;
    int data;
    int rc;
    bool agent;
};

namespace {
    uv_mutex_t waiting;
    uv_async_t sweep_queue;
    uv_thread_t usb_thread;
    std::queue<Baton*> pending;
    
    inline VitaContext *context(const v8::Arguments& args) {
        return static_cast<VitaContext*>(args.This()->GetPointerFromInternalField(0));
    }
}

// This calls any pending Node callbacks.
void handle_signal(uv_async_t *handle, int status) {
    uv_mutex_lock(&waiting);

    // process any pending callbacks to node.
    while(!pending.empty()) {
        Baton *it = pending.front();
        uv_mutex_unlock(&waiting);
        it->call();

        uv_mutex_lock(&waiting);
        pending.pop();
        
        if (it->agent) continue;
        delete it;
    }

    uv_mutex_unlock(&waiting);
}

// Function passed to all vita functions that callback.
// Runs on the EventThread
void handle_data(int data, void *user) {
    Baton *baton = static_cast<Baton*>(user);
    baton->data = data;

    uv_mutex_lock(&waiting);
    // add to pending queue.
    pending.push(baton);
    
    uv_mutex_unlock(&waiting);

    // call handle_signal in the main thread
    uv_async_send(&sweep_queue);
}

void EIO_EventThread(void *arg) {
    while (1) {
        vita_poll(NULL, 100000);
    }
}

// Constructor function for device.
// ====================================================================
v8::Handle<v8::Value> New(const v8::Arguments& args) {
    v8::HandleScope scope;

    if (args.Length() < 1) {
        return v8::ThrowException(v8::Exception::TypeError(v8::String::New("First argument must be a string.")));
    }

    // Device url
    v8::String::Utf8Value url(args[0]->ToString());
    trace("device string: %s\n", *url);
    VitaContext *ctx = vita_open(*url);

    if (ctx == NULL) {
        return v8::ThrowException(v8::Exception::Error(v8::String::New("Failed to attach to device.")));
    }

    v8::Handle<v8::Object> self = args.This();
    self->SetPointerInInternalField(0, ctx);

    uv_ref((uv_handle_t*)&sweep_queue);

    return scope.Close(self);
}


// SetOutputs
// ====================================================================
v8::Handle<v8::Value> SetOutputs(const v8::Arguments& args) {
    v8::HandleScope scope;

    Baton *baton = new Baton(args);

    baton->group = args[0]->ToInteger()->Value();
    baton->channel = args[1]->ToInteger()->Value();
    baton->data = args[2]->ToInteger()->Value();

    VitaContext *ctx = context(args);
    baton->rc = vita_set_outputs(ctx, baton->group, baton->channel, baton->data);

    baton->call(); 

    return scope.Close(args.This());
};


// GetInputs
// ====================================================================
v8::Handle<v8::Value> GetInputs(const v8::Arguments& args) {
    v8::HandleScope scope;

    Baton *baton = new Baton(args);

    baton->group = args[0]->ToInteger()->Value();
    baton->channel = args[1]->ToInteger()->Value();

    VitaContext *ctx = context(args);
    baton->rc = vita_request_inputs(ctx, baton->group, baton->channel, handle_data, baton);
    
    if (baton->rc < 0) {
        // return error to node immediately.
        baton->call();
    }

    return scope.Close(args.This());
}

// SetProperty
// ====================================================================
v8::Handle<v8::Value> SetProperty(const v8::Arguments& args) {
    v8::HandleScope scope;
    VitaContext *ctx = context(args);

    Baton *baton = new Baton(args);

    baton->group = args[0]->ToInteger()->Value();
    baton->channel = args[1]->ToInteger()->Value();
    baton->property = args[2]->ToInteger()->Value();
    baton->data = args[3]->ToInteger()->Value();

    baton->rc = vita_set_property(ctx, baton->group, baton->channel, baton->property, baton->data);

    baton->call(); 

    return scope.Close(args.This());
};


// GetProperty
// ====================================================================
v8::Handle<v8::Value> GetProperty(const v8::Arguments& args) {
    v8::HandleScope scope;
    VitaContext *ctx = context(args);

    Baton *baton = new Baton(args);

    baton->group = args[0]->ToInteger()->Value();
    baton->channel = args[1]->ToInteger()->Value();
    baton->property = args[2]->ToInteger()->Value();

    baton->rc = vita_request_property(ctx, baton->group, baton->channel, baton->property, handle_data, baton);

    if (baton->rc < 0) {
        // return error to node immediately.
        baton->call();
    }

    return scope.Close(args.This());
}

// Agents
// ====================================================================
v8::Handle<v8::Value> AddAgent(const v8::Arguments& args) {
    v8::HandleScope scope;
    VitaContext *ctx = context(args);

    Baton *baton = new Baton(args);

    baton->group = args[0]->ToInteger()->Value();
    baton->channel = args[1]->ToInteger()->Value();
    baton->property = args[2]->ToInteger()->Value();
    baton->agent = true;

    baton->rc = vita_start_agent(ctx, baton->group, baton->channel, baton->property, handle_data, baton);

    if (baton->rc < 0) {
        baton->call();
    }

    return scope.Close(v8::Integer::New(baton->rc));
}

v8::Handle<v8::Value> StopAgent(const v8::Arguments& args) {
    v8::HandleScope scope;
    VitaContext *ctx = context(args);

    Baton *baton = new Baton(args);

    baton->rc = vita_stop_agent(ctx, 0);

    if (baton->rc < 0) {
        baton->call();
    }

    return scope.Close(args.This());
}

// close
// ====================================================================
v8::Handle<v8::Value> Close(const v8::Arguments& args) {
    v8::HandleScope scope;
    VitaContext *ctx = context(args);
    //vita_close(ctx);

    uv_unref((uv_handle_t*)&sweep_queue);

    return scope.Close(args.This());
}

// Module Init
// ====================================================================
void init(v8::Handle<v8::Object> target) {
    // TODO: Figure out how to call vita_destroy
    //vita_destroy(ctx);
    v8::HandleScope scope;

    vita_init();

    uv_mutex_init(&waiting);
    uv_async_init(uv_default_loop(), &sweep_queue, handle_signal);
    uv_unref((uv_handle_t*)&sweep_queue);
    uv_thread_create(&usb_thread, EIO_EventThread, NULL);

    v8::Persistent<v8::FunctionTemplate> ctor = v8::Persistent<v8::FunctionTemplate>::New(v8::FunctionTemplate::New(New));
    ctor->InstanceTemplate()->SetInternalFieldCount(1);
    ctor->SetClassName(v8::String::NewSymbol("create"));

    NODE_SET_PROTOTYPE_METHOD(ctor, "setOutputs", SetOutputs);
    NODE_SET_PROTOTYPE_METHOD(ctor, "getInputs", GetInputs);

    NODE_SET_PROTOTYPE_METHOD(ctor, "setProperty", SetProperty);
    NODE_SET_PROTOTYPE_METHOD(ctor, "requestProperty", GetProperty);
    
    NODE_SET_PROTOTYPE_METHOD(ctor, "addAgent", AddAgent);
    NODE_SET_PROTOTYPE_METHOD(ctor, "stopAgent", StopAgent);

    NODE_SET_PROTOTYPE_METHOD(ctor, "close", Close);

    target->Set(v8::String::NewSymbol("Vita"), ctor->GetFunction());
}

NODE_MODULE(vita, init)
